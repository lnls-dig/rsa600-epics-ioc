//export EPICS_CA_MAX_ARRAY_BYTES=50000000

program sncExample

// needed for calling seq_pvPut from embedded C code 
foreign ssId;

%%#include <stdlib.h>
%%#include "/opt/include/RSA_API.h"

%{

static bool spectrum_settings(double span, double rbw, double vbw, int traceLen)
{
	ReturnStatus rs;

	SpectrumWindows window = SpectrumWindow_Kaiser;//Use the default window (Kaiser).
	SpectrumVerticalUnits verticalUnit = SpectrumVerticalUnit_dBm;//Use the default vertical units (dBm).

	Spectrum_Settings setSettings, getSettings;
	setSettings.span = span;
	setSettings.rbw = rbw;
	setSettings.enableVBW = true;
	setSettings.vbw = vbw;
	setSettings.traceLength = traceLen;
	setSettings.window = window;
	setSettings.verticalUnit = verticalUnit;

	rs = SPECTRUM_SetSettings(setSettings);
	//printf("\nERROR: %s", DEVICE_GetErrorString(rs));
	
	rs = SPECTRUM_GetSettings(&getSettings);
	//printf("\nERROR: %s", DEVICE_GetErrorString(rs));

	/*
	printf("\nSpan: %f\n", getSettings.span);
	printf("\nRBW: %f\n", getSettings.rbw);
	printf("\nVBW: %f\n", getSettings.vbw);
	printf("\nTrace lenght: %d\n", getSettings.traceLength);
	printf("\nStart freq: %f\n", getSettings.actualStartFreq);
	printf("\nStop freq: %f\n", getSettings.actualStopFreq);
	printf("\nFreq step size: %f\n", getSettings.actualFreqStepSize);
	printf("\nFreq span: %f\n", getSettings.span);
	*/
	
}

static bool center_freq(double freq)
{
	ReturnStatus rs;
	rs = CONFIG_SetCenterFreq(freq);
	printf("\nERROR: %s", DEVICE_GetErrorString(rs));
	rs = CONFIG_GetCenterFreq(&freq);
	printf("\nERROR: %s", DEVICE_GetErrorString(rs));

	printf("\nFrequency: %f\n", freq);
	
}

float get_spectrum(SS_ID ssID, float* traceAmp, VAR_ID traceAmpId, double* traceFreq, VAR_ID traceFreqId)
{
	ReturnStatus rs;

	int n;

	Spectrum_Settings getSettings;
	rs = SPECTRUM_GetSettings(&getSettings);

	int traceLength = getSettings.traceLength;//801, 2401, 4001, 8001,10401, 16001, 32001, and 64001 points
	double freq, stepfreq;
	freq = getSettings.actualStartFreq;
	stepfreq = getSettings.actualFreqStepSize;
	printf("\nFreq: %f, Step: %f\n", freq, stepfreq);
	
	for (n = 0; n < 64001; n++)
	{
		traceFreq[n] = freq/1000000.0;
		if (n < traceLength)
			freq = freq + stepfreq;
	}
	printf("\n\nCenter freq: %f\n\n", traceFreq[(traceLength-1)/2]);

	//Start the trace capture.
	rs = SPECTRUM_SetEnable(true);
	printf("\nSPECTRUM_SetEnable: %s", DEVICE_GetErrorString(rs));

	bool isActive = true;
	int waitTimeoutMsec= 500;//Maximum allowable wait time for each data acquistion.
	int numTimeouts = 2;//Maximum amount of attempts to acquire data if a timeout occurs.
	//Note: the total wait time to acquire data is waitTimeoutMsec x numTimeouts.
    int timeoutCount = 0;//Variable to track the timeouts.
	int traceCount = 0;
	bool traceReady = false;
	int outTracePoints;

	float* pTraceData = (float*)malloc(sizeof(float)*traceLength);

	while(isActive)
	{
		printf("\nTrace %d",traceCount);
		rs = SPECTRUM_AcquireTrace();
		printf("\nSPECTRUM_AcquireTrace: %s", DEVICE_GetErrorString(rs));
		//Wait for the trace to be ready.
		rs = SPECTRUM_WaitForTraceReady(waitTimeoutMsec,&traceReady);
		printf("\nSPECTRUM_WaitForTraceReady: %s, traceReady: %d", DEVICE_GetErrorString(rs), traceReady);
		if(traceReady)
		{
			//Get spectrum trace data.
			rs = SPECTRUM_GetTrace(0,traceLength,traceAmp,&outTracePoints);
			//Get traceInfo struct.
			Spectrum_TraceInfo traceInfo;
			rs = SPECTRUM_GetTraceInfo(&traceInfo);
			//You can use this information to report any non-zero bits in AcqDataStatus word, for example.
			if (traceInfo.acqDataStatus != 0)
				printf("\nTrace:%i AcqDataStatus:0x%04X\n", traceCount, traceInfo.acqDataStatus);
			
		traceCount++;

		}
		else timeoutCount++;

		//Stop acquiring traces when the limit is reached or the wait time is exceeded.
		if(timeoutCount == numTimeouts || traceCount == 1)
		{
			if (traceCount == 0)
			{
				printf("\ninit2()\n");
				rs = SPECTRUM_SetEnable(false);
				rs = SPECTRUM_SetEnable(true);
				//init2(ssID, traceAmp, traceAmpId, traceFreq, traceFreqId);
			}
			isActive = false;
		}
	}

	for (n = traceLength; n < 64001; n++)
	{
		traceAmp[n] = traceAmp[traceLength-1];
	}

	seq_pvPut(ssID, traceAmpId, SYNC);

	seq_pvPut(ssID, traceFreqId, SYNC);

	return traceAmp[(traceLength-1)/2];

	//Disconnect the device and finish up.
	//rs = SPECTRUM_SetEnable(false);
	
}

float get_spectrum_sweep(SS_ID ssID, float* traceAmp, VAR_ID traceAmpId, double* traceFreq, VAR_ID traceFreqId, float* SweepAmp, VAR_ID SweepAmpId, double* SweepFreq, VAR_ID SweepFreqId, double startfreq, double stopfreq, int points)
{
	ReturnStatus rs;

	int n;
	int dfreq = (int)((stopfreq-startfreq)/(points-1));
	printf("\nStep freq: %d, Points: %d\n", dfreq, points);
	double freq;
	int numpoint = 0;
	float maxAmp;
	int maxAmpIndex;

	for(freq = startfreq; freq <= stopfreq; freq=freq+dfreq)
	{
		rs = CONFIG_SetCenterFreq(freq);
		
		SweepAmp[numpoint] = get_spectrum(ssID, traceAmp, traceAmpId, traceFreq, traceFreqId);
		SweepFreq[numpoint] = freq;
		printf("\nFreq: %f, Amp: %f, Point: %d\n", SweepAmp[numpoint], SweepFreq[numpoint], numpoint);
		
		seq_pvPut(ssID, SweepAmpId, SYNC);
	
		seq_pvPut(ssID, SweepFreqId, SYNC);
		numpoint++;
	}

	for (n = numpoint; n < 101; n++)
	{
		SweepFreq[n] = SweepFreq[numpoint-1];
		SweepAmp[n] = SweepAmp[numpoint-1];
	}

	seq_pvPut(ssID, SweepAmpId, SYNC);

	seq_pvPut(ssID, SweepFreqId, SYNC);
}

static void init()
{
	ReturnStatus rs;
	int numDev;
	int devID[DEVSRCH_MAX_NUM_DEVICES];
	char devSN[DEVSRCH_MAX_NUM_DEVICES][DEVSRCH_SERIAL_MAX_STRLEN];
	char devType[DEVSRCH_MAX_NUM_DEVICES][DEVSRCH_TYPE_MAX_STRLEN];
	rs = DEVICE_Search(&numDev, devID, devSN, devType);
	
	printf("\nDevices detected: %d\n",numDev);

	rs = DEVICE_Connect(devID[0]);
	
	if (rs)
	{
		printf("\nERROR: %s", DEVICE_GetErrorString(rs));
	}
	//If there is no error connecting, then print the name of the connected device.
	else
		printf("\nCONNECTED TO: %s", devType[0]);
	
}

void init2(SS_ID ssID, float* traceAmp, VAR_ID traceAmpId, double* traceFreq, VAR_ID traceFreqId)
{
	//Search for devices.
	int numDev=2;
	int devID[DEVSRCH_MAX_NUM_DEVICES];
	char devSN[DEVSRCH_MAX_NUM_DEVICES][DEVSRCH_SERIAL_MAX_STRLEN];
	char devType[DEVSRCH_MAX_NUM_DEVICES][DEVSRCH_TYPE_MAX_STRLEN];
	wchar_t **deviceSerial;
	ReturnStatus rs;
	rs = DEVICE_Search(&numDev, devID, devSN, devType);
	
	printf("\nDevices detected: %d\n",numDev);
	printf("\nDevID: %d, Serial Number: %s, Device Type: %s\n",devID[0],devSN[0],devType[0]);
	
	if (numDev == 0)
	{
		printf("\nCan't find device connected");
		goto end;
	}
	
	//Connect to the first device found.
	rs = DEVICE_Connect(devID[0]);
	
	//The following is an example on how to use the return status of an API function.
	//For simplicity, it will not be used in the rest of the program.
	//This is a fatal error: the device could not be connected.
	if (rs)
	{
		printf("\nERROR: %s", DEVICE_GetErrorString(rs));
		goto end;
	}
	//If there is no error connecting, then print the name of the connected device.
	else
		printf("\nCONNECTED TO: %s", devType[0]);
	
	// Tracking Generator Setup
	bool trkgen_aval, trkgen_en;
	double trkgen_leveldBm = -10.0;
	rs = TRKGEN_GetHwInstalled(&trkgen_aval);
	printf("\nTrack Generator Installed: %d", trkgen_aval);
	
	if (trkgen_aval)
	{
		rs = TRKGEN_SetEnable(true);
		rs = TRKGEN_GetEnable(&trkgen_en);
		printf("\nTrack gen enable: %d", trkgen_en);
		// Range: 43 dBm to â€“3dBm
		rs = TRKGEN_SetOutputLevel(trkgen_leveldBm);
		rs = TRKGEN_GetOutputLevel(&trkgen_leveldBm);
		printf("\nTrack Output Level: %f", trkgen_leveldBm);
	}
	
	//bool TgBrEnable = false;
	//rs = SetTgBridgeEnable(TgBrEnable);
	//rs = GetTgBridgeEnable(&TgBrEnable);
	//printf("\nTgBrEnable %d\n",TgBrEnable);
	//rs = SetTgSweepParams(450e6, 550e6, 101, 10);
	//printf("\nSetTgSweepParams: %s", DEVICE_GetErrorString(rs));
	//       Track Generator Sweep not working
	//rs = TgSweepRun();
	//printf("\nTgSweepRun: %s", DEVICE_GetErrorString(rs));
	
	
	//Assign a trace to use. In this example, use trace 1 of 3.
	SpectrumTraces traceID = SpectrumTrace1;
	double span = 100e3;//The span of the trace.
	double rbw = 100; //Resolution bandwidth.

	//SpectrumWindow_Kaiser = 0,
	//SpectrumWindow_Mil6dB = 1,
	//SpectrumWindow_BlackmanHarris = 2,
	//SpectrumWindow_Rectangle = 3,
	//SpectrumWindow_FlatTop = 4,
	//SpectrumWindow_Hann = 5

	SpectrumWindows window = SpectrumWindow_Kaiser;//Use the default window (Kaiser).
	SpectrumDetectors detector = SpectrumDetector_PosPeak;//Use the default detector (positive peak).
	SpectrumVerticalUnits vertunits = SpectrumVerticalUnit_dBm;//Use the default vertical units (dBm).
	int traceLength = 10401;//801, 2401, 4001, 8001,10401, 16001, 32001, and 64001 points
	int numTraces = 1;//This will be the number of traces to acquire.
	char fn[10] = "TRACE.txt";//This will be the output filename.

	//Get the limits for the spectrum acquisition control settings.
	Spectrum_Limits salimits;
	rs = SPECTRUM_GetLimits(&salimits);
	
	printf("\nSpectrum limits\n");
	printf("\nMax span: %f", salimits.maxSpan);
	printf("\nMin span: %f", salimits.minSpan);
	printf("\nMax rbw: %f", salimits.maxRBW);
	printf("\nMin rbw: %f", salimits.minRBW);
	printf("\nMax vbw: %f", salimits.maxVBW);
	printf("\nMin vbw: %f", salimits.minVBW);
	printf("\nMax trace length: %d", salimits.maxTraceLength);
	printf("\nMin trace length: %d", salimits.minTraceLength);

	if (span > salimits.maxSpan) span = salimits.maxSpan;//You can use this information to check the limits.

	printf("\nActual span: %f", span);

	// Set SA controls to default, and get the control values.
	Spectrum_Settings setSettings, getSettings;
	rs = SPECTRUM_SetDefault();
	double cf = 500e6;
	rs = CONFIG_SetCenterFreq(cf);
	double refLevel;
	rs = CONFIG_GetReferenceLevel(&refLevel);
	printf("\nRef level: %f\n",refLevel);
	//rs = SPECTRUM_GetSettings(&setSettings);

	//Assign user settings to settings struct.
	setSettings.span = span;
	setSettings.rbw = rbw;
	setSettings.enableVBW = false;
	setSettings.vbw = 100;
	setSettings.traceLength = traceLength;
	setSettings.window = window;
	setSettings.verticalUnit = vertunits;

	//Register the settings.
	rs = SPECTRUM_SetSettings(setSettings);
	
	//Retrieve the settings info.
	rs = SPECTRUM_GetSettings(&getSettings);
	printf("\nTrace lenght: %d\n", getSettings.traceLength);
	printf("\nStart freq: %f\n", getSettings.actualStartFreq);
	printf("\nStop freq: %f\n", getSettings.actualStopFreq);
	printf("\nFreq step size: %f\n", getSettings.actualFreqStepSize);
	printf("\nFreq span: %f\n", getSettings.span);

	//Allocate memory array for spectrum output vector.
	float* pTraceData = (float*)malloc(sizeof(float)*traceLength);
	
	//Start the trace capture.
	rs = SPECTRUM_SetEnable(true);
	printf("\nTrace capture is starting...\n");
	bool isActive = true;
	int waitTimeoutMsec= 1000;//Maximum allowable wait time for each data acquistion.
	int numTimeouts = 20;//Maximum amount of attempts to acquire data if a timeout occurs.
	//Note: the total wait time to acquire data is waitTimeoutMsec x numTimeouts.
    int timeoutCount = 0;//Variable to track the timeouts.
	int traceCount = 0;
	bool traceReady = false;
	int outTracePoints;

	rs = SPECTRUM_AcquireTrace();
	//Wait for the trace to be ready.
	rs = SPECTRUM_WaitForTraceReady(waitTimeoutMsec,&traceReady);

	/*
	while(isActive)
	{
		printf("\nTrace %d\n",traceCount);
		rs = SPECTRUM_AcquireTrace();
		//Wait for the trace to be ready.
		rs = SPECTRUM_WaitForTraceReady(waitTimeoutMsec,&traceReady);
		printf("\nSPECTRUM_WaitForTraceReady: %s, traceReady: %d", DEVICE_GetErrorString(rs), traceReady);
		if(traceReady)
		{
			//Get spectrum trace data.
			rs = SPECTRUM_GetTrace(traceID,traceLength,traceAmp,&outTracePoints);
			//Get traceInfo struct.
			Spectrum_TraceInfo traceInfo;
			rs = SPECTRUM_GetTraceInfo(&traceInfo);
			//You can use this information to report any non-zero bits in AcqDataStatus word, for example.
			if (traceInfo.acqDataStatus != 0)
				printf("\nTrace:%i AcqDataStatus:0x%04X\n", traceCount, traceInfo.acqDataStatus);
			
			//Write data to the open file.

		traceCount++;

		}
		else timeoutCount++;

		//Stop acquiring traces when the limit is reached or the wait time is exceeded.
		if(numTraces == traceCount || timeoutCount == numTimeouts)
			isActive = false;
	}

	int n;
	double freq, stepfreq;
	freq = getSettings.actualStartFreq;
	stepfreq = getSettings.actualFreqStepSize;
	printf("\nFreq: %f, Step: %f\n", freq, stepfreq);
	
	for (n = 0; n < traceLength; n++)
	{
		traceFreq[n] = freq;
		freq = freq + stepfreq;
	}

	seq_pvPut(ssID, traceAmpId, SYNC);

	seq_pvPut(ssID, traceFreqId, SYNC);
	*/
	//Disconnect the device and finish up.
	//rs = SPECTRUM_SetEnable(false);
	if(pTraceData)
		free(pTraceData);

	//rs = DEVICE_Stop();
	//rs = DEVICE_Disconnect();

	end:
	printf("\nSpectrum trace acquisition routine complete.\n");
}

static void trkgen_enable(int enable)
{
	bool getenable;
	if (enable == 1)
	{
		printf("\nTRKGEN_SetEnable(true)\n");
		//TRKGEN_SetEnable(true);
		SetTgEnable(true);
	}
	else
	{
		printf("\nTRKGEN_SetEnable(false)\n");
		//TRKGEN_SetEnable(false);
		SetTgEnable(false);
	}
	GetTgEnable(&getenable);
	printf("\nTRKGEN_GetEnable %d\n", getenable);

}

}%

%%//----------------------------------------
%%// 	      Monitored PVs
%%//----------------------------------------

double maxFreq;
assign maxFreq to "{user}:freq.DRVH";

double minFreq;
assign minFreq to "{user}:freq.DRVL";

double freq;
assign freq to "{user}:freq";
monitor freq;
evflag freqFlag;
sync freq freqFlag;

double StartFreq;
assign StartFreq to "{user}:StartFreq";
monitor StartFreq;

double StopFreq;
assign StopFreq to "{user}:StopFreq";
monitor StopFreq;

int SweepPoints;
assign SweepPoints to "{user}:SweepPoints";
monitor SweepPoints;

double maxSpan;
assign maxSpan to "{user}:span.DRVH";

double minSpan;
assign minSpan to "{user}:span.DRVL";

double hoprSpan;
assign hoprSpan to "{user}:span.HOPR";

double loprSpan;
assign loprSpan to "{user}:span.LOPR";

double span;
assign span to "{user}:span";
monitor span;
evflag spanFlag;
sync span spanFlag;

double maxRBW;
assign maxRBW to "{user}:rbw.DRVH";

double minRBW;
assign minRBW to "{user}:rbw.DRVL";

double rbw;
assign rbw to "{user}:rbw";
monitor rbw;
evflag rbwFlag;
sync rbw rbwFlag;

double maxVBW;
assign maxVBW to "{user}:vbw.DRVH";

double minVBW;
assign minVBW to "{user}:vbw.DRVL";

double vbw;
assign vbw to "{user}:vbw";
monitor vbw;
evflag vbwFlag;
sync vbw vbwFlag;

int traceLenOpt, traceLenMenu[8] = {801, 2401, 4001, 8001, 10401, 16001, 32001, 64001};
assign traceLenOpt to "{user}:traceLenOpt";
monitor traceLenOpt;
evflag traceLenFlag;
sync traceLenOpt traceLenFlag;

int getSpec;
assign getSpec to "{user}:getSpec";
monitor getSpec;

int Sweep;
assign Sweep to "{user}:Sweep";
monitor Sweep;

int trkgen;
assign trkgen to "{user}:trkgenEn";
monitor trkgen;
evflag trkgenFlag;
sync trkgen trkgenFlag;

float traceAmp[64001];
assign traceAmp to "{user}:traceAmp";

double traceFreq[64001];
assign traceFreq to "{user}:traceFreq";

float SweepAmp[64001];
assign SweepAmp to "{user}:SweepAmpData";

double SweepFreq[64001];
assign SweepFreq to "{user}:SweepFreqData";

ss ss1 {
    state init {
	
	when (delay(0.1)) {
		init2(ssId, traceAmp, pvIndex(traceAmp), traceFreq, pvIndex(traceFreq));

		%{
		
		ReturnStatus rs;
		// Get device limits

		double maxCF, minCF;
		rs = CONFIG_GetMaxCenterFreq(&maxCF);
		rs = CONFIG_GetMinCenterFreq(&minCF);

		Spectrum_Limits salimits;
		rs = SPECTRUM_GetLimits(&salimits);
		
		printf("\nSpectrum limits\n");
		printf("\nMax span: %f", salimits.maxSpan);
		printf("\nMin span: %f", salimits.minSpan);
		printf("\nMax rbw: %f", salimits.maxRBW);
		printf("\nMin rbw: %f", salimits.minRBW);
		printf("\nMax vbw: %f", salimits.maxVBW);
		printf("\nMin vbw: %f", salimits.minVBW);
		printf("\nMax trace length: %d", salimits.maxTraceLength);
		printf("\nMin trace length: %d", salimits.minTraceLength);
	
		// Set SA controls to default, and get the control values.
		Spectrum_Settings getSettings;
		rs = SPECTRUM_SetDefault();
		SPECTRUM_GetSettings(&getSettings);
		printf("\n********* Initial parameters *********\n");
		printf("\nSpan: %f\n", getSettings.span);
		printf("\nRBW: %f\n", getSettings.rbw);
		printf("\nVBW: %f\n", getSettings.vbw);
		printf("\nTrace lenght: %d\n", getSettings.traceLength);
		printf("\nStart freq: %f\n", getSettings.actualStartFreq);
		printf("\nStop freq: %f\n", getSettings.actualStopFreq);
		printf("\nFreq step size: %f\n", getSettings.actualFreqStepSize);
		printf("\nFreq span: %f\n", getSettings.span);
		printf("\n********* Initial parameters *********\n");
		
		}%
		
		maxFreq = maxCF;
		pvPut(maxFreq);
		
		minFreq = minCF;
		pvPut(minFreq);
		
		maxSpan = salimits.maxSpan;
		pvPut(maxSpan);
		
		minSpan = salimits.minSpan;
		pvPut(minSpan);
		
		hoprSpan = salimits.maxSpan;
		pvPut(hoprSpan);
		
		loprSpan = salimits.minSpan;
		pvPut(loprSpan);
		
		maxRBW = salimits.maxRBW;
		pvPut(maxRBW);
		
		minRBW = salimits.minRBW;
		pvPut(minRBW);
		
		maxVBW = salimits.maxVBW;
		pvPut(maxVBW);
		
		minVBW = salimits.minVBW;
		pvPut(minVBW);
		
		//span = getSettings.span;
		//pvPut(span, SYNC);
		
		//rbw = getSettings.rbw;
		//pvPut(rbw, SYNC);
		
		//vbw = getSettings.vbw;
		//pvPut(vbw, SYNC);

		//traceLen = getSettings.traceLength;
		//pvPut(traceLen, SYNC);
		
	    printf("sncExample: Startup delay over\n");

	} state opr

    }
    state opr {

	when (efTestAndClear(spanFlag)) {
	    printf("Span change to: %f\n",span);
	    spectrum_settings(span, rbw, vbw, traceLenMenu[traceLenOpt]);
	} state opr

	when (efTestAndClear(rbwFlag)) {
	    printf("Rbw change to: %f\n",rbw);
	    spectrum_settings(span, rbw, vbw, traceLenMenu[traceLenOpt]);
	} state opr

	when (efTestAndClear(vbwFlag)) {
	    printf("Vbw change to: %f\n",vbw);
	    spectrum_settings(span, rbw, vbw, traceLenMenu[traceLenOpt]);
	} state opr

	when (efTestAndClear(traceLenFlag)) {
	    printf("TraceLen change to: %d\n",traceLenMenu[traceLenOpt]);
	    spectrum_settings(span, rbw, vbw, traceLenMenu[traceLenOpt]);
	} state opr

	when (efTestAndClear(freqFlag)) {
	    printf("Frequency change to: %f\n",freq);
	    center_freq(freq);
	} state opr

	when (efTestAndClear(trkgenFlag)) {
		trkgen_enable(trkgen);
	} state opr

	when (getSpec == 1) {
	    get_spectrum(ssId, traceAmp, pvIndex(traceAmp), traceFreq, pvIndex(traceFreq));
	} state opr

	when (Sweep == 1) {
	    get_spectrum_sweep(ssId, traceAmp, pvIndex(traceAmp), traceFreq, pvIndex(traceFreq), SweepAmp, pvIndex(SweepAmp), SweepFreq, pvIndex(SweepFreq), StartFreq, StopFreq, SweepPoints);
	    Sweep = 0;
	    pvPut(Sweep);
	} state opr

    }
}
