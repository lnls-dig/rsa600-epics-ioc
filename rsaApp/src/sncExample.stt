//export EPICS_CA_MAX_ARRAY_BYTES=50000000

program sncExample

// needed for calling seq_pvPut from embedded C code 
foreign ssId;

%%#include <stdlib.h>
%%#include "C:\\Tektronix\\RSA_API\\include\\RSA_API.h"

%{

// Define settings for the spectrum plotting.
static bool spectrum_settings(double span, double rbw, double vbw, int vbwEn, int traceLen)
{
	ReturnStatus rs;

	SpectrumWindows window = SpectrumWindow_Kaiser;//Use the default window (Kaiser).
	SpectrumVerticalUnits verticalUnit = SpectrumVerticalUnit_dBm;//Use the default vertical units (dBm).

	Spectrum_Settings setSettings, getSettings;
	setSettings.span = span;
	setSettings.rbw = rbw;
	setSettings.enableVBW = vbwEn;
	setSettings.vbw = vbw;
	setSettings.traceLength = traceLen;
	setSettings.window = window;
	setSettings.verticalUnit = verticalUnit;

	rs = SPECTRUM_SetSettings(setSettings);
	//printf("\nERROR: %s", DEVICE_GetErrorString(rs));
	
	rs = SPECTRUM_GetSettings(&getSettings);
	//printf("\nERROR: %s", DEVICE_GetErrorString(rs));

	
	printf("\nSpan: %f\n", getSettings.span);
	printf("\nRBW: %f\n", getSettings.rbw);
	printf("\nVBW: %f\n", getSettings.vbw);
	printf("\nVBW En: %s\n", getSettings.enableVBW ? "ON" : "OFF");
	printf("\nTrace lenght: %d\n", getSettings.traceLength);
	printf("\nStart freq: %f\n", getSettings.actualStartFreq);
	printf("\nStop freq: %f\n", getSettings.actualStopFreq);
	printf("\nFreq step size: %f\n", getSettings.actualFreqStepSize);
	
}

// Define the center frequency value, in Hz.
double set_center_freq(double freq)
{
	ReturnStatus rs;
	rs = CONFIG_SetCenterFreq(freq);
	printf("\nWRITE_ERROR: %s", DEVICE_GetErrorString(rs));
	printf("\nFrequency: %f\n", freq);
	
	return freq;
}

// Read the center frequency value, in Hz.
double get_center_freq(double freqRB)
{
	ReturnStatus rs;
	rs = CONFIG_GetCenterFreq(&freqRB);
	printf("\nREAD_ERROR: %s", DEVICE_GetErrorString(rs));
	printf("\nRead_Frequency: %f\n", freqRB);
	
	return freqRB;
}

// Set the reference level value, in dBm.
double set_ref_level(double refLevel)
{
	ReturnStatus rs;
	rs = CONFIG_SetReferenceLevel(refLevel);
	DEVICE_Run();
	printf("\nWRITE ERROR: %s", DEVICE_GetErrorString(rs));
	printf("\nWrite Ref level: %f\n", refLevel);
	
	return refLevel;
}

// Get the reference level value, in dBm.
double get_ref_level(double refLevelRB)
{
	ReturnStatus rs;
	rs = CONFIG_GetReferenceLevel(&refLevelRB);
	printf("\nREAD ERROR: %s", DEVICE_GetErrorString(rs));
	printf("\nRead Ref level: %f\n", refLevelRB);
	
	return refLevelRB;
}

// Reset the frequency array and clean the stored values when a change is made in one of the spectrum settings. Then the n
// frequency and amplitude acquisitions overwrite the first n elements (n=traceLength) in this array.
static void set_freq_array(SS_ID ssID, double* traceFreq, float* traceAmp)
{
	Spectrum_Settings getSettings;
	SPECTRUM_GetSettings(&getSettings);

	int n;
	double freq = getSettings.actualStartFreq;
	double stepfreq = getSettings.actualFreqStepSize;
	int traceLength = getSettings.traceLength;
	
	for (n = 0; n < 64001; n++)
	{
		traceFreq[n] = freq/1000000.0;
		traceAmp[n] = -150.0;
		if (n < traceLength)
		{
			freq = freq + stepfreq;
		}
	}
}

// Get the spectrum trace
int get_spectrum(SS_ID ssID, float* traceAmp, VAR_ID traceAmpId, double* traceFreq, VAR_ID traceFreqId, int traceLength)
{
	ReturnStatus rs;

	int n;

	//Start the trace capture.
	rs = SPECTRUM_SetEnable(true);
	//printf("\nSPECTRUM_SetEnable: %s", DEVICE_GetErrorString(rs));

	bool isActive = true;
	int waitTimeoutMsec= 500;//Maximum allowable wait time for each data acquistion.
	int numTimeouts = 2;//Maximum amount of attempts to acquire data if a timeout occurs.
	//Note: the total wait time to acquire data is waitTimeoutMsec x numTimeouts.
    int timeoutCount = 0;//Variable to track the timeouts.
	int traceCount = 0;
	bool traceReady = false;
	int outTracePoints;

	float* pTraceData = (float*)malloc(sizeof(float)*traceLength);

	time_t timeSec;
	uint64_t timeNsec;

	while(isActive)
	{
		//printf("\nTrace %d",traceCount);
		rs = SPECTRUM_AcquireTrace();
		//printf("\nSPECTRUM_AcquireTrace: %s", DEVICE_GetErrorString(rs));
		//Wait for the trace to be ready.
		rs = SPECTRUM_WaitForTraceReady(waitTimeoutMsec,&traceReady);
		//printf("\nSPECTRUM_WaitForTraceReady: %s, traceReady: %d", DEVICE_GetErrorString(rs), traceReady);
		if(traceReady)
		{
			//Get spectrum trace data.
			rs = SPECTRUM_GetTrace(0,traceLength,traceAmp,&outTracePoints);
			//Get traceInfo structure
			Spectrum_TraceInfo traceInfo;
			rs = SPECTRUM_GetTraceInfo(&traceInfo);
			//You can use this information to report any non-zero bits in AcqDataStatus word, for example.
			REFTIME_GetTimeFromTimestamp(traceInfo.timestamp, &timeSec, &timeNsec);
			//printf("\nsec: %d, nsec: %d\n", timeSec, timeNsec);
			if (traceInfo.acqDataStatus != 0)
				printf("\nTrace:%i AcqDataStatus:0x%04X\n", traceCount, traceInfo.acqDataStatus);
			
		traceCount++;

		}
		else timeoutCount++;

		//Stop acquiring traces when the limit is reached or the wait time is exceeded.
		if(timeoutCount == numTimeouts || traceCount == 1)
		{
			if (traceCount == 0)
			{
				printf("\nTimeout\n");
				rs = SPECTRUM_SetEnable(false);
				rs = SPECTRUM_SetEnable(true);
			}
			isActive = false;
		}
	}

	seq_pvPut(ssID, traceAmpId, SYNC);

	seq_pvPut(ssID, traceFreqId, SYNC);

	rs = SPECTRUM_SetEnable(false);
	return (int)timeSec;

}

double tune_measurement(SS_ID ssID, float* PeakAmp, VAR_ID PeakAmpId, double* PeakFreq, VAR_ID PeakFreqId, float* traceAmp, double* traceFreq, int traceLen, int delta, double TuneFreq, double * TuneMeas)
{
	int n, peak1i, peak2i;
	peak1i = 0;
	peak2i = 0;	
	float peak1, peak2;
	peak1 = -150.0;
	peak2 = -150.0;
	
	for(n = 0; n < traceLen; n++)
	{
		if (traceAmp[n] > peak1)
		{
			peak1 = traceAmp[n];
			peak1i = n;
		}
	}
	
	for(n = 0; n < traceLen; n++)
	{
		if ((traceAmp[n] > peak2) && (traceAmp[n] < peak1) && (fabs(peak1i-n) >= delta))
		{
			peak2 = traceAmp[n];
			peak2i = n;
		}
	}
	
	PeakFreq[0] = traceFreq[peak1i];
	PeakFreq[1] = traceFreq[peak2i];
	TuneMeas[0] = traceFreq[peak1i] - TuneFreq;
	TuneMeas[1] = traceFreq[peak2i] - TuneFreq;
	seq_pvPut(ssID, PeakFreqId, SYNC);

	PeakAmp[0] = peak1;
	PeakAmp[1] = peak2;
	seq_pvPut(ssID, PeakAmpId, SYNC);

	return (PeakFreq[0]-PeakFreq[1]);
}

float get_spectrum_sweep(SS_ID ssID, float* traceAmp, VAR_ID traceAmpId, double* traceFreq, VAR_ID traceFreqId, float* SweepAmp, VAR_ID SweepAmpId, double* SweepFreq, VAR_ID SweepFreqId, double startfreq, double stopfreq, int points)
{
	ReturnStatus rs;

	int n;
	int dfreq = (int)((stopfreq-startfreq)/(points-1));
	printf("\nStep freq: %d, Points: %d\n", dfreq, points);
	double freq;
	int numpoint = 0;
	float maxAmp;
	int maxAmpIndex;

	for(freq = startfreq; freq <= stopfreq; freq=freq+dfreq)
	{
		rs = CONFIG_SetCenterFreq(freq);
		
		SweepAmp[numpoint] = get_spectrum(ssID, traceAmp, traceAmpId, traceFreq, traceFreqId, 801);
		SweepFreq[numpoint] = freq;
		printf("\nFreq: %f, Amp: %f, Point: %d\n", SweepAmp[numpoint], SweepFreq[numpoint], numpoint);
		
		seq_pvPut(ssID, SweepAmpId, SYNC);
	
		seq_pvPut(ssID, SweepFreqId, SYNC);
		numpoint++;
	}
	
	for (n = numpoint; n < 1000; n++)
	{
		SweepFreq[n] = SweepFreq[numpoint-1];
		SweepAmp[n] = SweepAmp[numpoint-1];
	}

	seq_pvPut(ssID, SweepAmpId, SYNC);

	seq_pvPut(ssID, SweepFreqId, SYNC);
}

static void init()
{
	ReturnStatus rs;
	int numDev;
	int devID[DEVSRCH_MAX_NUM_DEVICES];
	char devSN[DEVSRCH_MAX_NUM_DEVICES][DEVSRCH_SERIAL_MAX_STRLEN];
	char devType[DEVSRCH_MAX_NUM_DEVICES][DEVSRCH_TYPE_MAX_STRLEN];
	rs = DEVICE_Search(&numDev, devID, devSN, devType);
	
	printf("\nDevices detected: %d\n",numDev);

	rs = DEVICE_Connect(devID[0]);
	
	if (rs)
	{
		printf("\nERROR: %s", DEVICE_GetErrorString(rs));
	}
	//If there is no error connecting, then print the name of the connected device.
	else
		printf("\nCONNECTED TO: %s", devType[0]);
	
}

int init2(SS_ID ssID, float* traceAmp, VAR_ID traceAmpId, double* traceFreq, VAR_ID traceFreqId, int deviceID)
{
	//Search for devices.
	int numDev;
	int devID[DEVSRCH_MAX_NUM_DEVICES];
	char devSN[DEVSRCH_MAX_NUM_DEVICES][DEVSRCH_SERIAL_MAX_STRLEN];
	char devType[DEVSRCH_MAX_NUM_DEVICES][DEVSRCH_TYPE_MAX_STRLEN];
	wchar_t **deviceSerial;
	ReturnStatus rs;
	rs = DEVICE_Search(&numDev, devID, devSN, devType);
	
	printf("\nDevices detected: %d\n",numDev);
	printf("\nDevID: %d, Serial Number: %s, Device Type: %s\n",devID[0],devSN[0],devType[0]);
	
	if (numDev == 0)
	{
		printf("\nCan't find device connected");
		goto end;
	}
	
	//Connect to the first device found.
	if (numDev == 1)
		rs = DEVICE_Connect(devID[0]);
	else
	{
		printf("\nConnecting to %d\n", deviceID);
		rs = DEVICE_Connect(devID[deviceID]);
	}
	
	//The following is an example on how to use the return status of an API function.
	//For simplicity, it will not be used in the rest of the program.
	//This is a fatal error: the device could not be connected.
	if (rs)
	{
		printf("\nERROR: %s", DEVICE_GetErrorString(rs));
		goto end;
	}
	//If there is no error connecting, then print the name of the connected device.
	else
		printf("\nCONNECTED TO: %s", devSN[deviceID]);

	//bool TgBrEnable = false;
	//rs = SetTgBridgeEnable(TgBrEnable);
	//rs = GetTgBridgeEnable(&TgBrEnable);
	//printf("\nTgBrEnable %d\n",TgBrEnable);
	//rs = SetTgSweepParams(450e6, 550e6, 101, 10);
	//printf("\nSetTgSweepParams: %s", DEVICE_GetErrorString(rs));
	//       Track Generator Sweep not working
	//rs = TgSweepRun();
	//printf("\nTgSweepRun: %s", DEVICE_GetErrorString(rs));
	
	
	//Assign a trace to use. In this example, use trace 1 of 3.
	SpectrumTraces traceID = SpectrumTrace1;
	double span = 100e3;//The span of the trace.
	double rbw = 100; //Resolution bandwidth.

	//SpectrumWindow_Kaiser = 0,
	//SpectrumWindow_Mil6dB = 1,
	//SpectrumWindow_BlackmanHarris = 2,
	//SpectrumWindow_Rectangle = 3,
	//SpectrumWindow_FlatTop = 4,
	//SpectrumWindow_Hann = 5

	SpectrumWindows window = SpectrumWindow_Kaiser;//Use the default window (Kaiser).
	SpectrumDetectors detector = SpectrumDetector_PosPeak;//Use the default detector (positive peak).
	SpectrumVerticalUnits vertunits = SpectrumVerticalUnit_dBm;//Use the default vertical units (dBm).
	int traceLength = 10401;//801, 2401, 4001, 8001,10401, 16001, 32001, and 64001 points
	int numTraces = 1;//This will be the number of traces to acquire.
	char fn[10] = "TRACE.txt";//This will be the output filename.

	//Get the limits for the spectrum acquisition control settings.
	Spectrum_Limits salimits;
	rs = SPECTRUM_GetLimits(&salimits);
	
	printf("\nSpectrum limits\n");
	printf("\nMax span: %f", salimits.maxSpan);
	printf("\nMin span: %f", salimits.minSpan);
	printf("\nMax rbw: %f", salimits.maxRBW);
	printf("\nMin rbw: %f", salimits.minRBW);
	printf("\nMax vbw: %f", salimits.maxVBW);
	printf("\nMin vbw: %f", salimits.minVBW);
	printf("\nMax trace length: %d", salimits.maxTraceLength);
	printf("\nMin trace length: %d", salimits.minTraceLength);

	if (span > salimits.maxSpan) span = salimits.maxSpan;//You can use this information to check the limits.

	printf("\nActual span: %f", span);

	// Set SA controls to default, and get the control values.
	Spectrum_Settings setSettings, getSettings;
	rs = SPECTRUM_SetDefault();
	double cf = 500e6;
	rs = CONFIG_SetCenterFreq(cf);
	double refLevel;
	rs = CONFIG_GetReferenceLevel(&refLevel);
	printf("\nRef level: %f\n",refLevel);
	//rs = SPECTRUM_GetSettings(&setSettings);

	//Assign user settings to settings struct.
	setSettings.span = span;
	setSettings.rbw = rbw;
	setSettings.enableVBW = false;
	setSettings.vbw = 100;
	setSettings.traceLength = traceLength;
	setSettings.window = window;
	setSettings.verticalUnit = vertunits;

	//Register the settings.
	rs = SPECTRUM_SetSettings(setSettings);
	
	//Retrieve the settings info.
	rs = SPECTRUM_GetSettings(&getSettings);
	printf("\nTrace lenght: %d\n", getSettings.traceLength);
	printf("\nStart freq: %f\n", getSettings.actualStartFreq);
	printf("\nStop freq: %f\n", getSettings.actualStopFreq);
	printf("\nFreq step size: %f\n", getSettings.actualFreqStepSize);
	printf("\nFreq span: %f\n", getSettings.span);

	//Allocate memory array for spectrum output vector.
	float* pTraceData = (float*)malloc(sizeof(float)*traceLength);
	
	//Start the trace capture.
	rs = SPECTRUM_SetEnable(true);
	printf("\nTrace capture is starting...\n");
	bool isActive = true;
	int waitTimeoutMsec= 1000;//Maximum allowable wait time for each data acquistion.
	int numTimeouts = 20;//Maximum amount of attempts to acquire data if a timeout occurs.
	//Note: the total wait time to acquire data is waitTimeoutMsec x numTimeouts.
    int timeoutCount = 0;//Variable to track the timeouts.
	int traceCount = 0;
	bool traceReady = false;
	int outTracePoints;

	rs = SPECTRUM_AcquireTrace();
	//Wait for the trace to be ready.
	rs = SPECTRUM_WaitForTraceReady(waitTimeoutMsec,&traceReady);

	//Disconnect the device and finish up.
	//rs = SPECTRUM_SetEnable(false);
	if(pTraceData)
		free(pTraceData);

	//rs = DEVICE_Stop();
	//rs = DEVICE_Disconnect();

	return 1;
	end:
	return 0;
}

// Enable/Disable auto-attenuation.
// As the equipment's API operates with bool values and the IOC with int values, this function also makes the needed conversion.
int set_auto_attenuation(int AutoAtt)
{
	if (AutoAtt)
		CONFIG_SetAutoAttenuationEnable(true);
	else
		CONFIG_SetAutoAttenuationEnable(false);
	
	DEVICE_Run();
	return (int)AutoAtt;
}

// Get auto-attenuation state.
int get_auto_attenuation(bool AutoAttSts)
{
	CONFIG_GetAutoAttenuationEnable(&AutoAttSts);
	return (int)AutoAttSts;
}
	
// Define the RF Input Attenuator value, in dB units.
double RF_attenuation(double value)
{
	CONFIG_SetRFAttenuator(value);
	DEVICE_Run();
	CONFIG_GetRFAttenuator(&value);
	return value;
}

// Enable/Disable the RF Preamplifier.
// As the equipment's API operates with bool values and the IOC with int values, this function also makes the needed conversion.
int set_pre_amplifier(int PreAmp)
{
	if (PreAmp)
		CONFIG_SetRFPreampEnable(true);
	else
		CONFIG_SetRFPreampEnable(false);
	
	DEVICE_Run();
	return (int)PreAmp;
}

// Get preamplifier state.
int get_pre_amplifier(bool PreAmpSts)
{
	CONFIG_GetRFPreampEnable(&PreAmpSts);
	printf("\nRead Preamp %d\n", PreAmpSts);
	return (int)PreAmpSts;
}

}%

%%//----------------------------------------
%%// 	      Monitored PVs
%%//----------------------------------------

double maxFreq;
assign maxFreq to "{P}{R}CenterFreq-SP.DRVH";

double minFreq;
assign minFreq to "{P}{R}CenterFreq-SP.DRVL";

double freq;
assign freq to "{P}{R}CenterFreq-SP";
monitor freq;
evflag freqFlag;
sync freq freqFlag;

double freqRB;
assign freqRB to "{P}{R}CenterFreq-RB";
monitor freqRB;

double refLevel;
assign refLevel to "{P}{R}RefLvl-SP";
monitor refLevel;
evflag refLevelFlag;
sync refLevel refLevelFlag;

double refLevelRB;
assign refLevelRB to "{P}{R}RefLvl-RB";

double StartFreq;
assign StartFreq to "{P}{R}StartFreq-SP";
monitor StartFreq;

double StopFreq;
assign StopFreq to "{P}{R}StopFreq-SP";
monitor StopFreq;

int SweepPoints;
assign SweepPoints to "{P}{R}SwePoints-SP";
monitor SweepPoints;

double maxSpan;
assign maxSpan to "{P}{R}Span-SP.DRVH";

double minSpan;
assign minSpan to "{P}{R}Span-SP.DRVL";

double hoprSpan;
assign hoprSpan to "{P}{R}Span-SP.HOPR";

double loprSpan;
assign loprSpan to "{P}{R}Span-SP.LOPR";

double span;
assign span to "{P}{R}Span-SP";
monitor span;
evflag spanFlag;
sync span spanFlag;

double spanRB;
assign spanRB to "{P}{R}Span-RB";

double maxRBW;
assign maxRBW to "{P}{R}Rbw-SP.DRVH";

double minRBW;
assign minRBW to "{P}{R}Rbw-SP.DRVL";

double rbw;
assign rbw to "{P}{R}Rbw-SP";
monitor rbw;
evflag rbwFlag;
sync rbw rbwFlag;

double rbwRB;
assign rbwRB to "{P}{R}Rbw-RB";

double maxVBW;
assign maxVBW to "{P}{R}Vbw-SP.DRVH";

double minVBW;
assign minVBW to "{P}{R}Vbw-SP.DRVL";

int vbwEn;
assign vbwEn to "{P}{R}EnblVbw-Sel";
monitor vbwEn;
evflag vbwEnFlag;
sync vbwEn vbwEnFlag;

int vbwEnSts;
assign vbwEnSts to "{P}{R}EnblVbw-Sts";

double vbw;
assign vbw to "{P}{R}Vbw-SP";
monitor vbw;
evflag vbwFlag;
sync vbw vbwFlag;

double vbwRB;
assign vbwRB to "{P}{R}Vbw-RB";

int traceLenOpt, traceLenMenu[8] = {801, 2401, 4001, 8001, 10401, 16001, 32001, 64001};
assign traceLenOpt to "{P}{R}TraceLenOpt-Sel";
monitor traceLenOpt;
evflag traceLenFlag;
sync traceLenOpt traceLenFlag;

int traceLenSts;
assign traceLenSts to "{P}{R}TraceLenOpt-Sts";

int getSpec;
assign getSpec to "{P}{R}GetSpec-Cmd";
monitor getSpec;

int Sweep;
assign Sweep to "{P}{R}InitSwe-Cmd";
monitor Sweep;

float traceAmp[64001];
assign traceAmp to "{P}{R}TraceAmp-Mon";

double traceFreq[64001];
assign traceFreq to "{P}{R}TraceFreq-Mon";

float PeakAmp[2];
assign PeakAmp to "{P}{R}PeakAmp-Mon";

double PeakFreq[2];
assign PeakFreq to "{P}{R}PeakFreq-Mon";

float SweepAmp[1000];
assign SweepAmp to "{P}{R}SweAmpData-Mon";

double SweepFreq[1000];
assign SweepFreq to "{P}{R}SweFreqData-Mon";

int AutoAtt;
assign AutoAtt to "{P}{R}EnblAutoAtt-Sel";
monitor AutoAtt;
evflag AutoAttFlag;
sync AutoAtt AutoAttFlag;

int AutoAttSts;
assign AutoAttSts to "{P}{R}EnblAutoAtt-Sts";

double RFAtt;
assign RFAtt to "{P}{R}InAtt-SP";
monitor RFAtt;
evflag RFAttFlag;
sync RFAtt RFAttFlag;

double RFAttRB;
assign RFAttRB to "{P}{R}InAtt-RB";

double TuneMeas[2];
assign TuneMeas to "{P}{R}TuneMeas-Mon";

double TuneFreq;
assign TuneFreq to "{P}{R}TuneFreq-Mon";
monitor TuneFreq;

int TuneDelta;
assign TuneDelta to "{P}{R}TuneDelta-Mon";

int PreAmp;
assign PreAmp to "{P}{R}EnblPreAmp-Sel";
monitor PreAmp;
evflag PreAmpFlag;
sync PreAmp PreAmpFlag;

int PreAmpSts;
assign PreAmpSts to "{P}{R}EnblPreAmp-Sts";

%%Spectrum_Limits salimits;

int timestamp, acqTimestamp, acqCount;

double AcqTime;
assign AcqTime to "{P}{R}AcqTime-Mon";

int initFlag = 0;

int deviceID;
assign deviceID to "{P}{R}DevID-Mon";
monitor deviceID;

ss ss1 {
    state init {
	
	when (initFlag == 1) {
	} state opr

	when (delay(0.1)) {
		initFlag = init2(ssId, traceAmp, pvIndex(traceAmp), traceFreq, pvIndex(traceFreq), deviceID, freq);

		%{
		
		ReturnStatus rs;
		// Get device limits

		double maxCF, minCF;
		rs = CONFIG_GetMaxCenterFreq(&maxCF);
		rs = CONFIG_GetMinCenterFreq(&minCF);

		//Spectrum_Limits salimits;
		rs = SPECTRUM_GetLimits(&salimits);
		
		printf("\nSpectrum limits\n");
		printf("\nMax span: %f", salimits.maxSpan);
		printf("\nMin span: %f", salimits.minSpan);
		printf("\nMax rbw: %f", salimits.maxRBW);
		printf("\nMin rbw: %f", salimits.minRBW);
		printf("\nMax vbw: %f", salimits.maxVBW);
		printf("\nMin vbw: %f", salimits.minVBW);
		printf("\nMax trace length: %d", salimits.maxTraceLength);
		printf("\nMin trace length: %d", salimits.minTraceLength);
	
		// Set SA controls to default, and get the control values.
		Spectrum_Settings getSettings;
		rs = SPECTRUM_SetDefault();
		SPECTRUM_GetSettings(&getSettings);
		printf("\n********* Initial parameters *********\n");
		printf("\nSpan: %f\n", getSettings.span);
		printf("\nRBW: %f\n", getSettings.rbw);
		printf("\nVBW: %f\n", getSettings.vbw);
		printf("\nTrace lenght: %d\n", getSettings.traceLength);
		printf("\nStart freq: %f\n", getSettings.actualStartFreq);
		printf("\nStop freq: %f\n", getSettings.actualStopFreq);
		printf("\nFreq step size: %f\n", getSettings.actualFreqStepSize);
		printf("\n********* Initial parameters *********\n");
		
		}%
		
		maxFreq = maxCF;
		pvPut(maxFreq);
		
		minFreq = minCF;
		pvPut(minFreq);
		
		maxSpan = salimits.maxSpan;
		pvPut(maxSpan);
		
		minSpan = salimits.minSpan;
		pvPut(minSpan);
		
		hoprSpan = salimits.maxSpan;
		pvPut(hoprSpan);
		
		loprSpan = salimits.minSpan;
		pvPut(loprSpan);
		
		maxRBW = salimits.maxRBW;
		pvPut(maxRBW);
		
		minRBW = salimits.minRBW;
		pvPut(minRBW);
		
		maxVBW = salimits.maxVBW;
		pvPut(maxVBW);
		
		minVBW = salimits.minVBW;
		pvPut(minVBW);
		
		refLevelRB = get_ref_level(refLevelRB);
		pvPut(refLevelRB);
		
		//span = getSettings.span;
		//pvPut(span, SYNC);
		
		//rbw = getSettings.rbw;
		//pvPut(rbw, SYNC);
		
		//vbw = getSettings.vbw;
		//pvPut(vbw, SYNC);

		//traceLen = getSettings.traceLength;
		//pvPut(traceLen, SYNC);

	} state init

    }
    state opr {

	when (efTestAndClear(spanFlag)) {
	    printf("Span change to: %f\n",span);
	    spectrum_settings(span, rbw, vbw, vbwEn, traceLenMenu[traceLenOpt]);
	    set_freq_array(ssId,traceFreq, traceAmp);
		
		spanRB = span;
		pvPut(spanRB);
	} state opr

	when (efTestAndClear(rbwFlag)) {
	    printf("Rbw change to: %f\n",rbw);
	    spectrum_settings(span, rbw, vbw, vbwEn, traceLenMenu[traceLenOpt]);
		
		rbwRB = rbw;
		pvPut(rbwRB);
	} state opr

	when (efTestAndClear(vbwFlag)) {
	    printf("Vbw change to: %f\n",vbw);
	    spectrum_settings(span, rbw, vbw, vbwEn, traceLenMenu[traceLenOpt]);
		
		vbwRB = vbw;
		pvPut(vbwRB);
	} state opr

	when (efTestAndClear(vbwEnFlag)) {
	    printf("Vbw enable: %s\n",vbwEn ? "ON" : "OFF");
	    spectrum_settings(span, rbw, vbw, vbwEn, traceLenMenu[traceLenOpt]);
		
		vbwEnSts = vbwEn;
		pvPut(vbwEnSts);
	} state opr

	when (efTestAndClear(traceLenFlag)) {
	    printf("TraceLen change to: %d\n",traceLenMenu[traceLenOpt]);
	    spectrum_settings(span, rbw, vbw, vbwEn, traceLenMenu[traceLenOpt]);
	    set_freq_array(ssId,traceFreq, traceAmp);
		
		traceLenSts = traceLenOpt;
		pvPut(traceLenSts);
	} state opr

	when (efTestAndClear(freqFlag)) {
	    printf("Frequency change to: %f\n",freq);
	    set_center_freq(freq);
	    set_freq_array(ssId,traceFreq, traceAmp);
		
		freqRB = get_center_freq(freqRB);
		pvPut(freqRB);
	} state opr

	when (efTestAndClear(refLevelFlag)) {
	    printf("Reference level change to: %f\n",refLevel);
	    set_ref_level(refLevel);
		
		refLevelRB = get_ref_level(refLevelRB);
		pvPut(refLevelRB);
	} state opr

	when (efTestAndClear(AutoAttFlag)) {
		set_auto_attenuation(AutoAtt);
		RFAtt = RF_attenuation(RFAtt);
		pvPut(RFAtt);
		
		AutoAttSts = get_auto_attenuation(AutoAttSts);
		pvPut(AutoAttSts);
	} state opr

	when (efTestAndClear(RFAttFlag)) {
		RFAtt = RF_attenuation(RFAtt);
		pvPut(RFAtt);
		
		RFAttRB = RFAtt;
		pvPut(RFAttRB);
	} state opr

	when (efTestAndClear(PreAmpFlag)) {
		set_pre_amplifier(PreAmp);
		
		PreAmpSts = get_pre_amplifier(PreAmpSts);
		pvPut(PreAmpSts);
	} state opr

	when (getSpec == 1) {
	    timestamp = get_spectrum(ssId, traceAmp, pvIndex(traceAmp), traceFreq, pvIndex(traceFreq), traceLenMenu[traceLenOpt]);
	    if (timestamp != acqTimestamp)
	    {
			acqTimestamp = timestamp;
			AcqTime = 1000/((double)acqCount);
			pvPut(AcqTime);
			acqCount = 1;
	    }
	    else
			acqCount++;
			
	    TuneDelta = ceil(3 * rbw * (traceLenMenu[traceLenOpt]-1)/ (span));
	    pvPut(TuneDelta);
	    tune_measurement(ssId, PeakAmp, pvIndex(PeakAmp), PeakFreq, pvIndex(PeakFreq), traceAmp, traceFreq, traceLenMenu[traceLenOpt], TuneDelta, TuneFreq, TuneMeas);
	    pvPut(TuneMeas);
	} state opr

	when (Sweep == 1) {
	    get_spectrum_sweep(ssId, traceAmp, pvIndex(traceAmp), traceFreq, pvIndex(traceFreq), SweepAmp, pvIndex(SweepAmp), SweepFreq, pvIndex(SweepFreq), StartFreq, StopFreq, SweepPoints);
	    Sweep = 0;
	    pvPut(Sweep);
	} state opr

    }
}
